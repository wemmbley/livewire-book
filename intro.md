# Livewire. Основные понятия.

Лайввайр строится прежде всего на компонентах. Их можно вызвать в любом месте блейд шаблона, даже в блейд шаблоне самого компонента, тем самым создав иерархию «компонент в компоненте» (однако такой подход может привести к некоторым трудномстям в будущем, которые далее будут описаны. Чаще всего такой подход лучше избегать, и делать компоненты независимыми друг от друга).

Компонент – это PHP класс + blade шаблон, которые общаются между собой посредством запросов клиент-сервер, позволяя в реальном времени изменять состояние PHP класса, либо же самого блейд файла. Далее под словом «класс компонента» будет имется ввиду исключительно PHP класс который наследуется от `Livewire\Component`, а его шаблон будет называться «шаблоном компонента», либо блейд файлом компонента. Все вместе на выходе дает полноценный компонент.

Класс компонента имеет в себе заготовленные методы, которые позволяют работать с его состоянием. Например метод `render()` – вызывается в момент, когда любой обычный блейд шаблон пытается получить лайвайр компонент. Это можно сделать двумя способами, но основной – прописать в блейде директиву `<livewire:component-name />`. 

Так же в момент вызова компонента в него можно передать некоторые параметры при необходимости, например вот так: `<livewire:component-name :dealId=«$id» />`, и тогда в свойство класса компонента будет записано значение `$id`, а само свойство должно будет именоваться `public $dealId;`.

Когда происходит вызов компонента, то лайввайр достает из контейнера ларавел инстанс нашего класса, и вызывает его метод `render()`, который должен вернуть строку с HTML разметкой, либо результат `view()` – `return view(‘my-component’);`. 

Важно отметить, что разметка должна иметь в себе только один корневой элемент, то есть нельзя возвращать нечто подобное: `<div></div><p></p>`, вместо этого все должно быть в root-блоке, например вот так: `<div><p></p></div>`. В противном случае, лайввайр выбросит исключение и компонент не будет инициализирован должным образом.

Так же из основных методов есть метод mount(), который выполняется до отрисовки шаблона компонента. В этом методе можно произвести запись в свойства класса компонента для последующей работы в шаблоне компонента. 

Например так: 
```php 
public $user;

public function mount() 
{
    $this->user = User::find(1);
}
```

И в таком случае в шаблоне компонента станет доступна переменная `{{ $user }}`.

# Биндинг и реактивность. 

Лайввайр своего рода является реактивным, поскольку при изменение данных сразу же отправляет их на сервер, регулярно синхронизируя свое текущее состояние. Для этого используется биндинг который подвязывает элемент к свойству класса компонента. Делается это с помощью `wire:model` в шаблоне компонента, и в значении передается название свойства класса компонента. Пример: `<input wire:model="title" type="text">` – таким образом при изменении значения `public $title` в классе, он будет синхронизирован с текстовым полем на фронте, и наоборот. Если текстовое поле изменилось, то сразу же меняется значение свойства класса. Как это работает в следующем параграфе.

# Синхронизация состояния компонента. 

Лайвайр регулярно обменивается запросами с бэком для того чтобы состояние компонента было всегда актуальным. Это происходит при условии каких-либо действий, например при изменении любого свойства класса компонента. В таком случае бэк сразу отправляет на фронт новое состояние всего компонента (при желании во вкладке Network браузера можно просмотреть в каком формате приходит компонент в запросе update). Это принуждает к перерисовке компонента на фронте. Подробнее об этом в следующем параграфе.

# Перерисовка шаблона компонента.

Когда с бэка приходит новое состояние компонента, которое отличается от текущего что есть на фронте, происходит перерисовка всего компонента. То есть фактически мы удаляем из DOM-дерева все содержимое нашего блейд файла который прописан в `render()` методе, и вставляем абсолютно новый кусок DOM'a. Для клиента никаких изменений не происходит, сайт не мигает от перерисовки, и все является плавным и незаметным. Однако, если нам пришло, например, новое значение `$title`, то содержимое инпута изменится исходя из нового состояния компонента.
